```cpp
1.哈夫曼树是带权路径长度最短的树，也叫最优二叉树。

2.二叉排序树 左子树小于根小于右子树 只有中序遍历符合。

3.Huffman树的结构不是唯一的。

4.平衡因子定义为该结点的左子树的深度减去右子树的深度，一个平衡二叉树中，某节点的左右孩子的平衡因子为0，说明左孩子的左子树和右子数的深度相同，而且右子树的左子树和右子数的深度相同，但这不能说明该节点的左子树和右子树的深度相同。

5.平衡因子定义为该结点的左子树的深度减去右子树的深度。

6.n个结点构成的不同二叉树个数为：C 2 n n /(n+1)

7.一棵左子树为空的二叉树,形态为右单支树,这样前序序列为根、右根... 
因为根结点在前序序列第一个,没有前序的前驱,这样根结点的左指针链域就是空的 
最下边的叶子（也就是最右边结点）是前序序列最后一个,没有前序的后继,因此该结点的右指针链域也是空的 
因此,空的链域合计2个

8.采用邻接表存储的图按深度优先搜索方法进行遍历的算法类似于二叉树的先序遍历。

9.在构成二叉排序树的过程中进行“平衡化”处理，成为二叉平衡树。

10.二叉树线索化后，先序线索化与后序线索化最多有1个空指针域，而中序线索化最多有2个空指针域。

11.度为m的哈夫曼树，只包含有度为0的结点和度为m的结点。

12.有n个节点的树结构，有n-1条边

13.设树中度为i（i=0，1，2，3，4）的结点数分别为Ni，树中结点总数为N，则树中各结点的度之和等于N-1，即N=1+N1+2N2+3N3+4N4=N0+N1+N2+N3+N4

14.树转换为二叉树时，树中每一个分支结点的所有子结点中的最右子结点无右孩子，根结点转换后也没有右孩子

15.最小二叉平衡树的节点的公式如下 F(n)=F(n-1)+F(n-2)+1，或者说深度为n的平衡二叉树，至少有F(n)个结点。

16.ltag为0时指向该结点的左孩子，为1时指向该结点的前驱；

17.树的先序，二叉树的先序;树的后序，二叉树的中序

18.哈夫曼编码和解码都是从根节点到叶子节点的

19.二叉排序树或者是一棵空树，或者是具有下列性质的二叉树：
（1）若左子树不空，则左子树上所有结点的值均小于它的根节点的值；
（2）若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值；
（3）左、右子树也分别为二叉排序树；
（4）没有键值相等的节点。

20.哈夫曼树的构造并不唯一，因为其左右子树位置交换，并不影响该二叉树的带权路径长度最小的性质。

21.树与二叉树是两种不同的树型结构，二叉树中孩子节点是有严格的左右之分的

22.遍历二叉树的算法中的基本操作是访问结点，则不论按哪一种次序进行遍历，对n个结点的二叉树，其时间复杂度均为O(n)。所需辅助空间为遍历过程中栈的最大容量，即树的深度，最坏情况下为n,则空间复杂度也为O(n)。

23.二叉树到森林的转换是：二叉树中节点的左孩子是森林中该节点的孩子，右孩子是森林中该节点的兄弟。

24.B树为二叉搜索树，
B-树是一种多路搜索树，是多叉树
B+树是B-树的变体，也是一种多路搜索树，在B-树的基础上做了一些改动。 B+的搜索与B-树也基本相同，区别是B+树只有达到叶子结点才命中（B-树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找；

25.若将树中每个结点的各子树看成是从左到右有次序的(即不能互换)，则称该树为有序树(Ordered Tree)

26.二叉排序树的主要用途是链式存储结构的二分查找，查找的最坏次数是树的高度，因此高度最小的二叉排序树是最佳的。

27.最小生成树的普里姆(Prim)算法中边上的权可正可负

28.Itag为0时，指向该节点的左孩子，为1时指向该节点前驱
Rtag为0时，指向该节点的右孩子，为1时指向该节点后继

29.广度和深度遍历是遍历算法，目的是遍历所有节点而不是获得最短路径，Dijkstra、A*等算法才是描述最短路径的方法

30.在树转换到二叉树的操作中，我们定义二叉树的一个结点的右儿子为该结点在未转换前的树中的兄弟结点。
树的根结点在转换为二叉树后为其根结点，而树的根结点没有兄弟结点，所以二叉树根的右子树为空。

31.如果T1是由有序树T转换而来的二叉树,那么T中结点的前序就是T1中结点的前序,T中结点的后序就是T1中结点的中序 就这2句话 记得就行

32.顺序存储一般只适用于完全二叉树，就是用一维数组存储二叉树中的结点

33.一般树的先根序遍历与对应的二叉树的先根序遍历序列一致，后根序遍历与对应二叉树的中根序遍历序列相同

34.

```
