```cpp
1.数组就是矩阵，矩阵就是数组，这种说法（ ）。
答：都错
原因：数组中的元素可以是字符等，矩阵中的只能是数。

2.下列哪两个数据结构，同时具有较高的查找和删除性能？（）
有序数组，有序链表，AVL树，Hash表
答：平衡二叉树的查找，插入和删除性能都是O(logN)，其中查找和删除性能较好；哈希表的查找、插入和删除性能都是O(1)，都是最好的。

3.数组优于链表的特点? 
答：存储空间小 的意思是 占用的存储空间少,由于链表结点需要持有额外的指针，因此所占用的空间较数组更大

4.数据结构具有记忆功能的是栈

5.在Visual C++和Mingw64平台，short a[100]，sizeof(a) 返回
答：200
原因：sizeof 返回的值表示的含义如下（单位字节）：
     数组 —— 编译时分配的数组空间大小； 
     指针 —— 存储该指针所用的空间大小（存储该指针的地址的长度，是长整型，应该为 4 ）； 
     类型 —— 该类型所占的空间大小； 
     对象 —— 对象的实际占用空间大小； 
     函数 —— 函数的返回类型所占的空间大小。函数的返回类型不能是 void 
short的大小为2字节；short [100]的大小就是200字节

6.在C语言中，顺序存储长度为3的字符串，需要占用（  4  ）个字节。
答：C语言中，字符串默认每个占用1字节，末尾还有'\0'，所以一共是4字节

7.对n个记录的线性表进行快速排序为减少算法的递归深度，每次分区后,先处理较短的部分
答：如果按长的递归优先的话，那么短的递归会一直保存在栈中，直到长的处理完。短的优先的话，长的递归调用没有进行，他是作为一个整体保存在栈中的，所以递归栈中的保留的递归数据少一些。

8.静态链表是用数组存储节点数据，模拟链表的实现，但是没有用到指针。每个数组节点包括两部分：data域和cursor（游标）域。data存储数据，cursor指明下个元素在数组中的下标。
（1）存取第i个元素时，需要从头遍历到i-1和元素，由第i-1个节点的cursor，才能知道第i个元素存储的位置，因此和i是相关的。
（2）使用数组对元素进行存储，在定义时大小已经确定。
（3）插入和删除操作无需移动元素，只需要修改cursor游标的值即可，就像修改动态链表中的指针一样。

9.稀疏矩阵一般的压缩存储方法有两种,即三元组和十字链表。

10.Char x[]=”abcdefg”;Char y[]={‘a’,’b’,’c’,’d’,’e’,’f’,’g’};
答：数组X的sizeof运算值大于数组Y的sizeof运算值
原因：x如此定义会在后面添加\0,所以x比y多一个结束符号

11. unshift()：向数组的开头添加一个或多个元素，改变原数组，返回新数组的长度

12.若有说明：a[3][4];，则数组 a 中初值无法确定，系统为所定义的数组在内存中开辟了已连续的存储单元，但这些存储单元中没有确定的值

13.索引顺序查找又称为分块查找，是介于顺序查找和二分查找之间的一种查找方法

14.广义表的元素可以为空

15.int[,] a = {{1,2,3}}；错误，大括号里少个逗号

16.double * array [8],array是一个数组，数组的每一个元素是指向双精度实型数据的指针

17.数组可看作基本线性表的一种推广，因此与线性表一样，可以对它进行插入、删除等操作，这样的说法正确吗？
不正确,数组越界不能插入

18.采用压缩存储后，对称矩阵是所有特殊矩阵中存储空间节约最多的。
不正确，稀疏矩阵才是。

19.循环队列
进队：队尾指针(rear+1)%m
出队：对头指针(front+1)%m
在队列中插入一个队列元素称为入队， 从队列中删除一个队列元素称为出队。 队列先进先出，所以出队头指针+1

20.
1、int(*p)[4];------ptr为指向含4个元素的一维整形数组的指针变量（是指针）
2、int *p[4];-------定义指针数组p，它由4个指向整型数据的指针元素组成（是数组）
3、int(*)[4];--------实际上可以看作是一种数据类型。也就是第一个（int(*p)[4];）

21.有一个100*90的稀疏矩阵,非0元素有10个,设每个整型数占2字节,则用三元组表示该矩阵时,所需的字节数是()
将非零元素所在行、列、非零元素的值构成一个三元组（i，j，v） ；
对于该题：
每个非零元素占3*2=6个字节，共10个非零元素，需6*10 = 60 个字节；
此外，还一般要用三个整数来存储矩阵的行数、列数和总元素个数，又需要3*2 = 6个字节；
总共：60 + 6 = 66 个字节。

22.队列添加元素是在对尾，删除元素是在对头；添加元素，尾指针rear+1;删除元素，头指针front+1;

23.a、数组是能被Object 一切能被Obj 接收的均为对象；
b、数组不是原生类 原生类有8种， int double boolean float byte short long char ；

24线性表有两种存储结构：
1.顺序存储结构---顺序表。顺序表以数组形式出现，可以取任意下标访问，所以是一种随机存取的存储结构。
2.链式存储结构---链表。链表以链表的形式出现，必须从头开始访问，所以是一种顺序存取的存储结构

25.vector erase以后，itor已经指向下一个元素了，不应该执行itor++，

26.和顺序栈相比,链栈有一个比较明显的优势是，通常不会出现栈满的情况
原因：因为顺序栈用数组实现，必须事先确定栈的大小，对内存的使用效率并不高，无法避免因数组空间用光而引起的溢出问题：
而链栈因为动态申请内存，一般不会出现栈满情况，空栈还是会出现的

27.数组一旦建立，结构的元素个数和元素间的物理存储关系就不再变化

28.在一个元素个数为N的数组里，找到升序排在N/5位置的元素的最优算法时间复杂度是O(n)
原因：使用基数排序或者计数排序搞一搞，时间复杂度O(n)

29.数组通常具有的两种基本操作是查找和修改，索引不是操作，只有接触到具体数组数据的才算是操作，索引只是数组的下标！

30.一维数组是线性结构，二维及多维不是线性结构。
线性结构是一个数据元素的有序集合，是指数据元素之间存在“一对一”的关系。
一维数组的下标，只能对应一个元素，属于线性结构。
二维及多维数组，可用矩阵来表示，他们都是两个或多个下标值对应一个元素，是多对一的关系，因此是非线性结构。

31.邻接表的性质，存在多少个结点，就有多少个头结点的数组，每个头结点的数组都指向该结点在图中直接相连的结点。

32.顺序表结构适宜于进行随机存取。

33.对数组的基本操作:查找和修改

34.稀疏矩阵在采用压缩存储后将会失去随机存储的功能。因为在这种矩阵中，非零元素的分布是没有规律的，为了压缩存储，就将每一个非零元素的值和它所在的行、列号做为一个结点存放在一起，这样的结点组成的线性表中叫三元组表，它已不是简单的向量，所以无法用下标直接存取矩阵中的元素。

35.线性表的顺序存储结构是一种随机存取的存储结构。

36.数组的大小也可以在运行时确定大小，即动态开辟空间。

37.a+sizeof(int) 实际是地址加4
```


