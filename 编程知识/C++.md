```cpp

1.常量成员才不能修改，静态成员变量必须初始化，但可以修改（例如我们常利用静态成员变量统计某个函数的调用次数）

2.static是加了访问控制的全局变量，不被继承

3.模板类的作用:(1)可用来创建动态增长和减小的数据结构 （2）它是类型无关的，因此具有很高的可复用性。 （3）它在编译时而不是运行时检查数据类型，保证了类型安全 （4）它是平台无关的，可移植性 （5）可用于基本数据类型

4.析构过程与构造过程相反，构造过程先调用基类构造函数，再调用派生类构造函数。析构就反过来，先调用派生类析构函数，再调用基类析构函数

5.:read和write函数除了都有文件IO的用法，还有一种用法就是用于输入流输入自定义大小的字符串以及用于输出流自定义大小的字符串

6. 类的私有成员只能被类中的成员函数访问,还可以被友元函数访问。

7. %o与%x都是针对unsigned int

8. 函数类型不能作为重载函数的调用的依据

9.在用作定义时char[0]是空数组，是不占空间的。如果定义char[1]，那么就是长度为1的数组，使用char[0]则表示这唯一的数据

10.通过拷贝函数可以将另一个对象作为对象的初值

11.数组名作为实参进行传递，则退化为指针，故不必说明数组的大小

12.指针和void*可以相互转化

13.用户自定义标识符由字母、数字和下划线组成，只能由字母或下划线开头

14.类静态成员数据为该类所有对象共享，在该类对象被撤销时，静态成员并不撤销。

15.对于一个结构体：(1)当前成员变量之前的总容量必须为此变量大小的整倍数 (2)整个结构体的总容量必须为最大成员变量的整数倍

16.三种继承方式：公有继承、保护继承、私有继承

17.构造函数私有化后，不能再使用 new 外部调用，私有方法只能类内部使用。

18.拷贝和赋值的区别：看赋值是否产生新的对象，如果产生新的对象则调用拷贝构造函数，没有产生新的对象，则调用的是赋值运算符

19.strstr() 函数搜索一个字符串在另一个字符串中的第一次出现。 该函数返回字符串的其余部分（从匹配点）。如果未找到所搜索的字符串，则返回 false。 语法 strstr(string,search)

20.后置++和->的优先级相同，从左到右结合。前置++优先级低于->

21.使用malloc系统调用分配的内存是在堆上分配的。

22.‖运算只要前面一个条件成立，对后面一个就不做运算

23.一个程序文件从本程序的main函数开始,到main函数结束

24.const修饰类的成员函数，一般放在函数体后，如 void fun() const; 

25.箭头（->）：左边必须为指针；点号（.）：左边必须为实体。

26.源程序中凡是行首以#标识的控制行都是预处理指令,预编译是对源文件部分内容(宏定义,条件指令,特殊符号)的替换

27.非静态成员不可以作为默认实参。

28.char *p （）： 是指针函数，函数；char (*p) （）：是函数指针，指针。

29.基类数据成员在基类构造函数里赋值，不能出现在派生类的构造函数参数列表里

30.类型之间可以进行强制转换 表示类型不安全。

31.指针指向字符串时，字符串是常量，存储在常量区，而指针存储在栈区，不能对其操作修改。

32.vector初始化方式有四种：
(1. vector<int> v(10); 表示创建size为10的vector,每个元素执行默认初始化；
(2. vector<int> v(10,1);表示创建size为10的vector,每个元素初始化为1；
(3. vector<int> v{1,2,3,4};表示创建size为4的vector，元素的值分别为1,2,3,4。 
(4. vector<int> v;  表示创建size为0的vector；

33.[X+Y]补=[X]补+[Y]补

34.如果表达式包含signed和unsigned int，signed会被转换为unsigned。如果int 操作数的值恰为负数，其转换为unsigned int可能会变为一个很大的正数（转换结果是该负值对unsigned int的取值个数求模）。

35.fscanf()作用是从文件流中读取数据，fprintf()是将数据写入到文件

36.const出现在*左边，如const char* p，表示p所指向的变量内容不可变，指针指向可以改变；
const出现在*右边，如char* const p，表示p是个常量指针，即不能指向其他变量，而指向的变量内容可变；
const出现在*左边和右边，如const char* const p，表示p的指向不能改变，指向的变量内容也不能改变。
```
